% Appendix A

\chapter{Code for Project}
\label{AppendixA}
\lhead{Appendix A. \emph{Code for Project}}
\section{STM32F4 Code}
\begin{lstlisting}
/* Includes */
#include "stm32f4xx.h"
#include "stm32f401_discovery.h"
#include "math.h"
/*
PD0 -> S11
PD1 -> S13
PD2 -> S21
PD3 -> S23
PD4 -> S12
PD5 -> S14
PD6 -> S22
PD7 -> S24
*/

const int sine_table[50] = { 2089, 1052, 0, 1052, 2088, 3092, 4046, 4937, 5750,
	6472, 7092, 7600, 7988, 8251, 8383, 8383, 8251, 7988, 7600, 7092, 6472,
	5750, 4937, 4046, 3092, 2089, 1052, 0, 1052, 2088, 3092, 4046, 4937,
	5750, 6472, 7092, 7600, 7988, 8251, 8383, 8383, 8251, 7988, 7600, 7092,
	6472, 5750, 4937, 4046, 3092 };

const int hex_values[17] = { 0xF0, 0xF0, 0xE1, 0x96, 0x87, 0xA5, 0x87, 0x96,
	0xE1, 0xF0, 0xD2, 0x69, 0x4B, 0x5A, 0x4B, 0x69, 0xD2 };
uint16_t arr_values[17] = { 0 };
uint8_t s11, s13, s21, s23, ss;
uint8_t index0 = 1, sin_index = 0;
uint16_t duty = 100;
float m_a = 1.0f;

void timer3_Init() {
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
	TIM_TimeBaseInitTypeDef tim;
	tim.TIM_Period = arr_values[0] - 1;
	tim.TIM_Prescaler = 9;
	tim.TIM_ClockDivision = TIM_CKD_DIV1;
	tim.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM3, &tim);
	
	NVIC_InitTypeDef nvic;
	nvic.NVIC_IRQChannel = TIM3_IRQn;
	nvic.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&nvic);
	
	TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);
	
	TIM_ARRPreloadConfig(TIM3, ENABLE);
	
	TIM_Cmd(TIM3, ENABLE);
}

void timer2_Init() {
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
	TIM_TimeBaseInitTypeDef tim;
	tim.TIM_Period = 33599;
	tim.TIM_Prescaler = 0;
	tim.TIM_ClockDivision = TIM_CKD_DIV1;
	tim.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM2, &tim);
	
	NVIC_InitTypeDef nvic;
	nvic.NVIC_IRQChannel = TIM2_IRQn;
	nvic.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&nvic);
	TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);
	
	TIM_ARRPreloadConfig(TIM2, ENABLE);
	TIM_Cmd(TIM2, ENABLE);
}

void init_GPIOs() {
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
	
	GPIO_InitTypeDef gpio;
	
	gpio.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3
	| GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;
	gpio.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_Init(GPIOD, &gpio);
	
	gpio.GPIO_Pin = GPIO_Pin_0;
	gpio.GPIO_Mode = GPIO_Mode_IN;
	GPIO_Init(GPIOA, &gpio);
}

void PWM_Init() {
	
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
	
	GPIO_InitTypeDef gpio;
	gpio.GPIO_Pin = GPIO_Pin_12;
	gpio.GPIO_Mode = GPIO_Mode_AF;
	gpio.GPIO_Speed = GPIO_Speed_100MHz;
	GPIO_Init(GPIOD, &gpio);
	
	GPIO_PinAFConfig(GPIOD, GPIO_PinSource12, GPIO_AF_TIM4);
	
	TIM_TimeBaseInitTypeDef tim;
	tim.TIM_Period = 8399;
	tim.TIM_Prescaler = 0;
	tim.TIM_ClockDivision = TIM_CKD_DIV1;
	tim.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM4, &tim);
	
	TIM_OCInitTypeDef tim_oc;
	tim_oc.TIM_OCMode = TIM_OCMode_PWM1;
	tim_oc.TIM_OCPolarity = TIM_OCPolarity_High;
	tim_oc.TIM_OutputState = TIM_OutputState_Enable;
	tim_oc.TIM_Pulse = 4199;
	TIM_OC1Init(TIM4, &tim_oc);
	TIM_OC1PreloadConfig(TIM4, TIM_OCPreload_Enable);
	TIM_Cmd(TIM4, ENABLE);
	
}

void init_ARR() {
	double p = 20; // 20ms, 50Hz
	double ca[4] = { 6, 22, 38, 60 }; //{ 6, 22, 38, 60 }; // {9.8409, 20.3828, 38.4054, 60.4164}
	double delay_time[17] = { 0 };
	double sum = 0;
	int i = 0;
	for (i = 0; i < 17; i++) {
		if (i < 4) {
			delay_time[i] = (ca[i] / 360) * p - sum;
			sum += delay_time[i];
		} else if (i == 4) {
			delay_time[i] = (p / 2 - (ca[3] / 360) * p) - sum;
		} else if (i > 4 && i < 8) {
			delay_time[i] = delay_time[8 - i];
		} else if (i == 8) {
			delay_time[i] = delay_time[0] * 2;
		} else if (i > 8 && i < 16) {
			delay_time[i] = delay_time[i - 8];
		} else if (i == 16) {
			delay_time[16] = delay_time[0];
		}
	}
	for (i = 0; i < 17; i++) {
		arr_values[i] = lround((double) (delay_time[i] * 8400));
	}
}

int main(void) {
	ss = 1;
	int index1 = 0;
	uint16_t CCR_value = 0;
	uint8_t AND = 2;
	uint8_t spwm = 0;
	init_GPIOs();
	init_ARR();
	PWM_Init();
	timer3_Init();
	if (spwm) {
		timer2_Init();
	}
	while (1) {
		if (!spwm) {
			CCR_value = (uint16_t) (((float) (duty / 100.0)) * 8400);
			TIM4->CCR1 = CCR_value;
		}
		index1 = index0 - 1;
		if (index1 < 0) {
			index1 = 16;
		}
		ss = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0);
		
		if (AND == 2) {
			GPIO_Write(GPIOD, (hex_values[index1]));
		}
		if (AND == 1) {
			GPIO_Write(GPIOD, (hex_values[index1] * ss));
		} else if (AND == 0) {
			
			GPIO_Write(GPIOD, (hex_values[index1]));
			
			if (index1 == 6 || index1 == 7 || index1 == 14 || index1 == 15) {
				if (ss == 0) {
					GPIO_Write(GPIOD, (hex_values[index1 + 1]));
				}
			}
			if (index1 == 2 || index1 == 8 || index1 == 10 || index1 == 16) {
				GPIO_Write(GPIOD, (hex_values[index1] * ss));
			}
			if (index1 == 3 || index1 == 4 || index1 == 5 || index1 == 11
			|| index1 == 12 || index1 == 13) {
				if (ss == 0) {
					GPIO_Write(GPIOD, (hex_values[index1 - 1]));
				}
			}
		}
		/*	s11 = GPIO_ReadOutputDataBit(GPIOD, GPIO_Pin_0);
		s13 = GPIO_ReadOutputDataBit(GPIOD, GPIO_Pin_1);
		s21 = GPIO_ReadOutputDataBit(GPIOD, GPIO_Pin_2);
		s23 = GPIO_ReadOutputDataBit(GPIOD, GPIO_Pin_3);*/
	}
}

void TIM3_IRQHandler() {
	if (TIM_GetITStatus(TIM3, TIM_IT_Update)) {
		TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
		
		TIM3->ARR = arr_values[index0] - 1;
		index0 = (index0 + 1) % 17;
		
	}
}

void TIM2_IRQHandler() {
	if (TIM_GetITStatus(TIM2, TIM_IT_Update)) {
		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
		TIM4->CCR1 = (uint16_t) (m_a * sine_table[sin_index]);
		sin_index = (sin_index + 1) % 50;
	}
}

/*
* Callback used by stm32f401_discovery_audio_codec.c.
* Refer to stm32f401_discovery_audio_codec.h for more info.
*/
void EVAL_AUDIO_TransferComplete_CallBack(uint32_t pBuffer, uint32_t Size) {
	/* TODO, implement your code here */
	return;
}

/*
* Callback used by stm32f401_discovery_audio_codec.c.
* Refer to stm32f401_discovery_audio_codec.h for more info.
*/
uint16_t EVAL_AUDIO_GetSampleCallBack(void) {
	/* TODO, implement your code here */
	return -1;
}
\end{lstlisting}

\section{MATLAB CODE}
\subsection{Switching Sequence Generator:}
\begin{lstlisting}
clear;clc;
%% Sequence Generator
% This script generates 4 switching sequences o11, 013, o21, o23 for
% switches Q11, Q13, Q21, Q23 respectively. o12, o14, o22 and o24 can be
% obtain by inverting o11, 013, o21, o23 respectively
% -------------------
%% Input
options.Interpreter = 'tex';
% Include the desired Default answer
options.Default = 'No PWM';
% Use the TeX interpreter in the question
qstring = 'Please Select Operation Mode?';
choice = questdlg(qstring,'Operation Mode',...
'No PWM','PWM Operation','SPWM Operation',options);

% Defining Variables
d = 100; % Duty
ma = 1.0; % Modulation Index

% Handle response
switch choice
case 'No PWM'
option = 0;
case 'PWM Operation'
option = 1;
answer = inputdlg("Enter Duty Value: ");
d = str2double(answer{1}); % Store Duty Value
case 'SPWM Operation'
option = 2;
answer = inputdlg("Enter Value of Modulaion Index: ");
ma = str2double(answer{1}); % Store Vlaue of Modulation Index
end
%% Initialization

Fs = 10000; % Samples per Period
p = 20e-3; % Time Period. (Variable Frequency can be obtain by changing period value)
t = linspace(0, p, Fs); % Time axis
duty = d; % From User Input
sw_freq = 10e3; % Switching Frequency for PWM Operation
if (option == 2) % Sine PWM
pwm = SPWM(sw_freq, t, ma);
end
if (option == 1) % PWM
pwm = (1 + square(2*pi*sw_freq*t, duty))/2;
end
if (option == 0) % No PWM
pwm = ones(1, Fs);
end
o11 = zeros(1, Fs);
o13 = zeros(1, Fs);
o21 = zeros(1, Fs);
o23 = zeros(1, Fs);
%% Data

% Conduction Angles or Switching Angles in Degrees
cond_angles = [6 22 38 60]; %(for SHE PWM)[9.8409 20.3828 38.4054 60.4164]; 

% Switching Sequence with minimum transitions
s11 = [0 1 0 1 1 1 0 1 0 0 1 1 0 1 1 0 0];
s13 = [0 0 1 1 0 1 1 0 0 1 0 1 1 1 0 1 0];
s21 = [0 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0];
s23 = [0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 0];

%% Calculations
%  Calculating Time Axis values of all steps based on conduction angles
time_value = [
(cond_angles(1)/360)*p
((cond_angles(2)/360)*p)
((cond_angles(3)/360)*p)
((cond_angles(4)/360)*p)
((p/2 - (cond_angles(4)/360)*p))
((p/2 - (cond_angles(3)/360)*p))
((p/2 - (cond_angles(2)/360)*p))
((p/2 - (cond_angles(1)/360)*p))
((p/2 + (cond_angles(1)/360)*p))
((p/2 + (cond_angles(2)/360)*p))
((p/2 + (cond_angles(3)/360)*p))
((p/2 + (cond_angles(4)/360)*p))
((p - (cond_angles(4)/360)*p))
((p - (cond_angles(3)/360)*p))
((p - (cond_angles(2)/360)*p))
((p - (cond_angles(1)/360)*p))
p
];
%% Output Generation
% Based on conduction angles generating sequences for Q11, Q13, Q21 and
% Q23
j = 1;
for i = 1:Fs
o11(i) = s11(j)*pwm(i);
o13(i) = s13(j)*pwm(i);
o21(i) = s21(j)*pwm(i);
o23(i) = s23(j)*pwm(i);

if t(i) > time_value(j)
j = j + 1;
end
end
\end{lstlisting}

\subsection{Sine PWM Generator}
\begin{lstlisting}
function y = SPWM(f, t, ma)
counter = 1;
y = zeros(1, length(t));
table = zeros(1, 200);
for angle = 0:0.9:179
table(counter) = ma*100*sind(angle);
counter = counter + 1;
end
sin_table = [table table];
del = length(t)/length(sin_table);
lower = 1;
upper = del;
angle = 1;
for counter = 1:del:length(t)
y(lower:upper) = (1 + square(2*pi*f*t(lower:upper), sin_table(angle)))/2;
lower = upper + 1;
upper = upper + del;
angle = angle + 1;
end

\end{lstlisting}

\subsection{SHE PWM}
\begin{lstlisting}
clear; clc;
% x = [9.8409   20.3828   38.4054   60.4164]
x0 = [6 22 38 60];
fun = @set_of_equations;
options = optimoptions('fsolve', 'MaxFunctionEvaluations', 20000, 'OptimalityTolerance', 1e-6, 'StepTolerance', 1e-6, 'MaxIterations', 2000, 'PlotFcn', @optimplotfval);
x = fsolve(fun, x0, options);
\end{lstlisting}
\subsection{Equations}
\begin{lstlisting}
function F = set_of_equations(x)
F = zeros(1,4);
F(1) = cosd(x(1)) + cosd(x(2)) + cosd(x(3)) + cosd(x(4)) - 3.2;
F(2) = cosd(5*x(1)) + cosd(5*x(2)) + cosd(5*x(3)) + cosd(5*x(4));
F(3) = cosd(7*x(1)) + cosd(7*x(2)) + cosd(7*x(3)) + cosd(7*x(4));
F(4) = cosd(11*x(1)) + cosd(11*x(2)) + cosd(11*x(3)) + cosd(11*x(4));
\end{lstlisting}